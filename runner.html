<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MasterPiets 2.0 - Runner</title>
<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/foundation-icons/3.0/foundation-icons.min.css" rel="stylesheet">
<style>
* { box-sizing: border-box; }
body { margin: 0; padding: 0; background: black; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; font-size: 14px; }

/* Floating panels */
.float-panel {
    position: fixed;
    z-index: 1000;
    background: white;
    border: 1px solid #ddd;
    border-radius: 5px;
    box-shadow: 2px 2px 8px rgba(0,0,0,0.2);
    user-select: none;
    min-width: 180px;
}
.float-panel-header {
    background: #eee;
    border-bottom: 1px solid #ddd;
    border-radius: 5px 5px 0 0;
    padding: 4px 8px;
    cursor: move;
    font-weight: bold;
    font-size: 12px;
}
.float-panel-body {
    padding: 5px;
}

#grid-table {
    margin: 0;
    table-layout: fixed;
    border-collapse: collapse;
}

#grid-table td {
    border: 1px solid black;
    max-height: 30px;
    max-width: 30px;
    text-align: center;
    color: white;
    font-size: 11px;
    text-shadow: 1px 1px 1px black;
    padding: 0;
    overflow: hidden;
}


#command-list {
    margin: 0;
    padding: 5px;
    width: 100%;
    height: 250px;
    resize: vertical;
    overflow: auto;
    font-family: monospace;
    font-size: 11pt;
    background-color: #f5f5f5;
    border: 1px solid #ccc;
}

#command-list .command-entry { text-transform: uppercase; cursor: pointer; }

.stack-table { margin: auto auto 1vh; width: 100%; }
.stack-table td {
    border: 1px solid black;
    width: 100%;
    height: 2ex;
    text-align: center;
    vertical-align: middle;
    font-family: monospace;
    font-size: 12pt;
    word-break: break-all;
}

textarea.io-field {
    width: 100%;
    max-width: 100%;
    font-family: monospace;
    font-size: 12pt;
}

/* Colour picker */
#colour-picker td {
    width: 32px;
    height: 32px;
    padding: 5px;
    border: 1px solid black;
    color: white;
    text-shadow: 1px 1px 1px black;
    text-align: center;
    cursor: pointer;
    font-size: 11px;
}
#colour-picker td.selected {
    border: 4px double black;
}

/* Paint mode button active style */
.paint-mode-btn.active-mode {
    background-color: #d4d4d4;
    box-shadow: inset 0 3px 5px rgba(0,0,0,.125);
}

/* Breakpoint stripe pattern - applied via JS */
</style>
</head>
<body>


<!-- Floating Panel: Canvas -->
<div class="float-panel" id="panel-canvas" style="left:10px; top:10px;">
    <div class="float-panel-header">Piet <span id="block-info" style="font-weight:normal; font-size:11px; color:#666;"></span></div>
    <div class="float-panel-body">
        <div id="grid-container">
            <table id="grid-table"><tbody id="grid-body"></tbody></table>
        </div>
    </div>
</div>

<!-- Floating Panel: Code -->
<div class="float-panel" id="panel-code" style="left:10px; top:10px; width:320px;">
    <div class="float-panel-header">Code</div>
    <div class="float-panel-body">
        <div style="margin-bottom:8px; display:flex; align-items:center; gap:6px; flex-wrap:wrap;">
            <label style="margin:0;">H</label>
            <input type="number" id="input-height" class="form-control" style="width:5em;" required value="10">
            <label style="margin:0;">W</label>
            <input type="number" id="input-width" class="form-control" style="width:5em;" required value="10">
            <input type="button" class="btn btn-warning btn-sm" value="Resize / Clear" id="resize-btn">
        </div>
        <div class="btn-toolbar" role="toolbar" style="margin-bottom:6px;">
            <input type="button" class="btn btn-primary btn-sm" value="Import" id="import-btn">
            <input id="fileChooser" type="file" accept="image/png, image/bmp, image/jpeg, image/gif" style="display:none">
            <div class="btn-group btn-group-sm">
                <button type="button" class="btn btn-info" id="export-btn">Export to PNG</button>
                <button type="button" class="btn btn-info dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    <span class="caret"></span>
                </button>
                <ul class="dropdown-menu">
                    <li>
                        <div class="form-group" style="margin-left:1vw; margin-bottom:0;">
                            <label class="control-label" for="scale">Scale</label>
                            <input id="scale" type="number" name="scale" class="form-control" style="width:5em; margin-left:4px; display:inline-block;" value="1" required>
                        </div>
                    </li>
                </ul>
            </div>
            <i class="glyphicon glyphicon-eye-close" id="bs-toggle" title="Show block sizes" style="font-size:16px; cursor:pointer; margin-left:4px; vertical-align:middle;"></i>
        </div>
        <table id="colour-picker"><tbody id="colour-picker-body"></tbody></table>
        <div class="btn-toolbar" role="toolbar" style="margin-top:8px;">
            <div class="btn-group btn-group-sm" role="group">
                <button type="button" title="Brush mode" class="btn btn-default paint-mode-btn active-mode" id="brush-btn" style="padding:2px 12px;">
                    <i class="fi-pencil" style="font-size:14pt;"></i>
                </button>
                <button type="button" title="Bucket mode" class="btn btn-default paint-mode-btn" id="bucket-btn" style="padding:2px 12px;">
                    <i class="fi-paint-bucket" style="font-size:14pt;"></i>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Floating Panel 1: Commands -->
<div class="float-panel" id="panel-commands" style="left:10px; top:10px; width:250px;">
    <div class="float-panel-header">Commands</div>
    <div class="float-panel-body">
        <div id="command-list"></div>
    </div>
</div>

<!-- Floating Panel 2: Controls + Pointers -->
<div class="float-panel" id="panel-controls" style="left:10px; top:10px; width:250px;">
    <div class="float-panel-header">Debug Controls</div>
    <div class="float-panel-body">
        <div class="btn-toolbar" role="toolbar" style="margin:0 0 8px;">
            <div class="btn-group btn-group-sm" style="width:52px; margin:0;">
                <button type="button" class="btn btn-success" title="Run from the beginning" id="debug-run">
                    <i class="glyphicon glyphicon-play"></i>
                </button>
                <button type="button" class="btn btn-success dropdown-toggle" title="Set run speed" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" style="width:18px; padding-left:4px; padding-right:4px;">
                    <span class="caret"></span>
                    <span class="sr-only">Toggle Dropdown</span>
                </button>
                <ul class="dropdown-menu">
                    <li style="padding:0 5px;">
                        <small style="float:left;">Slower</small>
                        <small style="float:right;">Faster</small>
                        <input type="range" min="0" max="1000" step="100" id="speed-slider" value="500">
                    </li>
                </ul>
            </div>
            <div class="btn-group btn-group-sm" role="group" style="width:136px; margin:0 0 0 4px;">
                <button type="button" class="btn btn-warning" title="Pause" id="debug-pause">
                    <i class="glyphicon glyphicon-pause"></i>
                </button>
                <button type="button" class="btn btn-info" title="Step" id="debug-step">
                    <i class="glyphicon glyphicon-step-forward"></i>
                </button>
                <button type="button" class="btn btn-primary" title="Continue running from this point" id="debug-cont">
                    <i class="glyphicon glyphicon-fast-forward"></i>
                </button>
                <button type="button" class="btn btn-danger" title="Stop" id="debug-stop">
                    <i class="glyphicon glyphicon-stop"></i>
                </button>
            </div>
            <i class="glyphicon glyphicon-map-marker" title="Set breakpoints" id="bp-toggle" style="font-size:18px; margin:0 0 0 3px; padding:5px 0; cursor:pointer;"></i>
        </div>
    </div>
</div>

<!-- Floating Panel 3: Stack -->
<div class="float-panel" id="panel-stack" style="left:10px; top:10px; width:250px;">
    <div class="float-panel-header">Stack</div>
    <div class="float-panel-body">
        <div id="pointers" style="width:100%; text-align:center; font-weight:bold; margin-bottom:5px;"></div>
        <div style="height:150px; resize:vertical; overflow-y:auto; overflow-x:hidden;">
            <table class="stack-table"><thead><tr><td><b>Stack</b></td></tr></thead><tbody id="stack-body"></tbody></table>
        </div>
    </div>
</div>

<!-- Floating Panel 4: Output -->
<!-- Floating Panel: Input -->
<div class="float-panel" id="panel-input" style="left:10px; top:10px; width:250px;">
    <div class="float-panel-header">Input</div>
    <div class="float-panel-body">
        <textarea id="in" class="io-field" placeholder="Enter input before running program" title="Tip: Whitespace before a numerical value is ignored"></textarea>
    </div>
</div>

<!-- Floating Panel: Output -->
<div class="float-panel" id="panel-output" style="left:10px; top:10px; width:250px;">
    <div class="float-panel-header">Output</div>
    <div class="float-panel-body">
        <textarea id="out" class="io-field" readonly></textarea>
    </div>
</div>

<script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

<script>
(function() {
'use strict';

// ============================================================
// COLOURS
// ============================================================
const colours = [
    '#FFC0C0', '#FFFFC0', '#C0FFC0', '#C0FFFF', '#C0C0FF', '#FFC0FF',
    '#FF0000', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#FF00FF',
    '#C00000', '#C0C000', '#00C000', '#00C0C0', '#0000C0', '#C000C0',
    '#FFFFFF', '#000000',
];
const WHITE = 18, BLACK = 19;

// Parse colour hex to RGB for import matching
function hexToRgb(hex) {
    const n = parseInt(hex.slice(1), 16);
    return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
}
const colourRgbs = colours.map(hexToRgb);

// ============================================================
// ORDERED COMMANDS (18x18 table)
// ============================================================
const commands = [
    ['','+','/','>', 'dup','in(char)','push','-','mod','pointer','roll','out(num)','pop','*','not','switch','in(num)','out(char)'],
    ['in(char)','','+','/','>', 'dup','out(num)','push','-','mod','pointer','roll','out(char)','pop','*','not','switch','in(num)'],
    ['dup','in(char)','','+','/','>', 'roll','out(num)','push','-','mod','pointer','in(num)','out(char)','pop','*','not','switch'],
    ['>','dup','in(char)','','+','/', 'pointer','roll','out(num)','push','-','mod','switch','in(num)','out(char)','pop','*','not'],
    ['/','>', 'dup','in(char)','','+', 'mod','pointer','roll','out(num)','push','-','not','switch','in(num)','out(char)','pop','*'],
    ['+','/','>', 'dup','in(char)','', '-','mod','pointer','roll','out(num)','push','*','not','switch','in(num)','out(char)','pop'],
    ['pop','*','not','switch','in(num)','out(char)', '','+'  ,'/','>', 'dup','in(char)','push','-','mod','pointer','roll','out(num)'],
    ['out(char)','pop','*','not','switch','in(num)', 'in(char)','','+','/','>', 'dup','out(num)','push','-','mod','pointer','roll'],
    ['in(num)','out(char)','pop','*','not','switch', 'dup','in(char)','','+','/','>', 'roll','out(num)','push','-','mod','pointer'],
    ['switch','in(num)','out(char)','pop','*','not', '>','dup','in(char)','','+','/', 'pointer','roll','out(num)','push','-','mod'],
    ['not','switch','in(num)','out(char)','pop','*', '/','>', 'dup','in(char)','','+', 'mod','pointer','roll','out(num)','push','-'],
    ['*','not','switch','in(num)','out(char)','pop', '+','/','>', 'dup','in(char)','', '-','mod','pointer','roll','out(num)','push'],
    ['push','-','mod','pointer','roll','out(num)', 'pop','*','not','switch','in(num)','out(char)', '','+'  ,'/','>', 'dup','in(char)'],
    ['out(num)','push','-','mod','pointer','roll', 'out(char)','pop','*','not','switch','in(num)', 'in(char)','','+','/','>', 'dup'],
    ['roll','out(num)','push','-','mod','pointer', 'in(num)','out(char)','pop','*','not','switch', 'dup','in(char)','','+','/','>' ],
    ['pointer','roll','out(num)','push','-','mod', 'switch','in(num)','out(char)','pop','*','not', '>','dup','in(char)','','+','/' ],
    ['mod','pointer','roll','out(num)','push','-', 'not','switch','in(num)','out(char)','pop','*', '/','>', 'dup','in(char)','','+'],
    ['-','mod','pointer','roll','out(num)','push', '*','not','switch','in(num)','out(char)','pop', '+','/','>', 'dup','in(char)',''],
];

// ============================================================
// INTERPRETER (generator-based, ported directly from original)
// ============================================================
function getNextColour(grid, height, width, row, col, DP, CC) {
    let origColour = grid[row][col];
    let visited = Array(height).fill(0).map(() => Array(width).fill(false));
    let farEdge = undefined;
    let stack = [[row, col]];

    while (stack.length > 0) {
        const [r, c] = stack.pop();
        if (r < 0 || c < 0 || r >= height || c >= width || visited[r][c] || grid[r][c] !== origColour) continue;
        visited[r][c] = true;

        switch (DP) {
            case 0: // right
                if (c + 1 === width || grid[r][c + 1] !== origColour) {
                    if (!farEdge || c + 1 > farEdge[1] ||
                        (c + 1 === farEdge[1] && ((CC && r > farEdge[0]) || (!CC && r < farEdge[0])))) {
                        farEdge = [r, c + 1];
                    }
                }
                break;
            case 1: // down
                if (r + 1 === height || grid[r + 1][c] !== origColour) {
                    if (!farEdge || r + 1 > farEdge[0] ||
                        (r + 1 === farEdge[0] && ((CC && c < farEdge[1]) || (!CC && c > farEdge[1])))) {
                        farEdge = [r + 1, c];
                    }
                }
                break;
            case 2: // left
                if (c === 0 || grid[r][c - 1] !== origColour) {
                    if (!farEdge || c - 1 < farEdge[1] ||
                        (c - 1 === farEdge[1] && ((CC && r < farEdge[0]) || (!CC && r > farEdge[0])))) {
                        farEdge = [r, c - 1];
                    }
                }
                break;
            case 3: // up
                if (r === 0 || grid[r - 1][c] !== origColour) {
                    if (!farEdge || r - 1 < farEdge[0] ||
                        (r - 1 === farEdge[0] && ((CC && c > farEdge[1]) || (!CC && c < farEdge[1])))) {
                        farEdge = [r - 1, c];
                    }
                }
                break;
        }

        stack.push([r, c + 1], [r + 1, c], [r, c - 1], [r - 1, c]);
    }

    return farEdge;
}

function* interpret(grid, blocks, blockSizes, getInputNum, getInputChar) {
    let height = grid.length, width = grid[0].length;
    let row = 0, col = 0;
    let DP = 0, CC = 0;
    let stack = [], output = '', commandList = [];
    let bounceCount = 0;
    let inst, nextColour, block, currCommand;

    function slide(r, c) {
        let nr = r, nc = c;
        switch (DP) {
            case 0: for (; nc < width && grid[r][nc] === WHITE; nc++); break;
            case 1: for (; nr < height && grid[nr][c] === WHITE; nr++); break;
            case 2: for (; nc >= 0 && grid[r][nc] === WHITE; nc--); break;
            case 3: for (; nr >= 0 && grid[nr][c] === WHITE; nr--); break;
        }
        return [nr, nc];
    }

    function slideOut(r, c) {
        function routeIsDoubled(array) {
            let len = array.length;
            if (!len || len % 2 !== 0) return false;
            let first = array.slice(0, len / 2), second = array.slice(len / 2);
            return first.every((elem, i) => elem[0] === second[i][0] && elem[1] === second[i][1]);
        }

        let [nr, nc] = slide(r, c);
        if (nr < 0 || nr >= height || nc < 0 || nc >= width || grid[nr][nc] === BLACK) {
            [nr, nc] = [r, c];
        } else {
            return [nr, nc];
        }

        let whiteRoute = [];
        while (!routeIsDoubled(whiteRoute)) {
            bounce(); bounce();
            [nr, nc] = slide(nr, nc);
            if (nr < 0 || nr >= height || nc < 0 || nc >= width || grid[nr][nc] === BLACK) {
                switch (DP) {
                    case 0: nc--; break;
                    case 1: nr--; break;
                    case 2: nc++; break;
                    case 3: nr++; break;
                }
                whiteRoute.push([nr, nc]);
            } else {
                return [nr, nc];
            }
        }
        return null;
    }

    function bounce() {
        bounceCount++;
        if (bounceCount % 2 !== 0) {
            CC = (CC + 1) % 2;
            return { CC };
        } else {
            DP = (DP + 1) % 4;
            return { DP };
        }
    }

    while (bounceCount < 8) {
        let colour = grid[row][col];
        let pushVal = blockSizes[row][col];
        let [nextRow, nextCol] = getNextColour(grid, height, width, row, col, DP, CC);

        if (nextRow < 0 || nextRow >= height || nextCol < 0 || nextCol >= width || grid[nextRow][nextCol] === BLACK) {
            yield bounce();
        } else if (grid[nextRow][nextCol] === WHITE) {
            let initDP = DP;
            let out = slideOut(nextRow, nextCol);
            if (DP !== initDP) yield { DP, CC };
            if (out == null) return;
            [row, col] = out;
            bounceCount = 0;
        } else {
            [row, col] = [nextRow, nextCol];
            bounceCount = 0;
            nextColour = grid[row][col];
            inst = commands[colour][nextColour];
            block = blocks[row][col];
            currCommand = { block, inst };

            switch (inst) {
                case 'push':
                    stack.push(pushVal);
                    currCommand.inst += ' ' + pushVal;
                    yield { commandList, block, currCommand, stack };
                    break;
                case 'pop': {
                    let op = stack.pop();
                    if (op === undefined) currCommand.error = 'stack underflow';
                    yield { commandList, block, currCommand, stack };
                    break;
                }
                case '+': {
                    let op1 = stack.pop(), op2 = stack.pop();
                    if (op1 === undefined || op2 === undefined) {
                        currCommand.error = 'stack underflow';
                        if (op1 !== undefined) stack.push(op1);
                    } else {
                        let result = op1 + op2;
                        if (!Number.isFinite(result)) {
                            currCommand.error = 'integer overflow';
                            yield { commandList, block, currCommand };
                            commandList.push(currCommand); yield { commandList }; return;
                        }
                        stack.push(result);
                    }
                    yield { commandList, block, currCommand, stack };
                    break;
                }
                case '-': {
                    let op1 = stack.pop(), op2 = stack.pop();
                    if (op1 === undefined || op2 === undefined) {
                        currCommand.error = 'stack underflow';
                        if (op1 !== undefined) stack.push(op1);
                    } else {
                        let result = op2 - op1;
                        if (!Number.isFinite(result)) {
                            currCommand.error = 'integer overflow';
                            yield { commandList, block, currCommand };
                            commandList.push(currCommand); yield { commandList }; return;
                        }
                        stack.push(result);
                    }
                    yield { commandList, block, currCommand, stack };
                    break;
                }
                case '*': {
                    let op1 = stack.pop(), op2 = stack.pop();
                    if (op1 === undefined || op2 === undefined) {
                        currCommand.error = 'stack underflow';
                        if (op1 !== undefined) stack.push(op1);
                    } else {
                        let result = op1 * op2;
                        if (!Number.isFinite(result)) {
                            currCommand.error = 'integer overflow';
                            yield { commandList, block, currCommand };
                            commandList.push(currCommand); yield { commandList }; return;
                        }
                        stack.push(result);
                    }
                    yield { commandList, block, currCommand, stack };
                    break;
                }
                case '/': {
                    let op1 = stack.pop(), op2 = stack.pop();
                    if (op1 === undefined || op2 === undefined) {
                        currCommand.error = 'stack underflow';
                        if (op1 !== undefined) stack.push(op1);
                    } else if (op1 === 0) {
                        currCommand.error = 'divide by zero';
                        stack.push(op2); stack.push(op1);
                    } else {
                        stack.push(Math.floor(op2 / op1));
                    }
                    yield { commandList, block, currCommand, stack };
                    break;
                }
                case 'mod': {
                    let op1 = stack.pop(), op2 = stack.pop();
                    if (op1 === undefined || op2 === undefined) {
                        currCommand.error = 'stack underflow';
                        if (op1 !== undefined) stack.push(op1);
                    } else if (op1 === 0) {
                        currCommand.error = 'divide by zero';
                        stack.push(op2); stack.push(op1);
                    } else {
                        stack.push(op2 - op1 * Math.floor(op2 / op1));
                    }
                    yield { commandList, block, currCommand, stack };
                    break;
                }
                case 'not': {
                    let op = stack.pop();
                    if (op === undefined) { currCommand.error = 'stack underflow'; }
                    else { stack.push(op === 0 ? 1 : 0); }
                    yield { commandList, block, currCommand, stack };
                    break;
                }
                case '>': {
                    let op1 = stack.pop(), op2 = stack.pop();
                    if (op1 === undefined || op2 === undefined) {
                        currCommand.error = 'stack underflow';
                        if (op1 !== undefined) stack.push(op1);
                    } else {
                        stack.push(op2 > op1 ? 1 : 0);
                    }
                    yield { commandList, block, currCommand, stack };
                    break;
                }
                case 'pointer': {
                    let op = stack.pop();
                    if (op === undefined) { currCommand.error = 'stack underflow'; }
                    else if (op > 0) { DP = (DP + op) % 4; }
                    else { DP = ((DP + (op % 4)) % 4 + 4) % 4; }
                    yield { commandList, block, currCommand, stack, DP };
                    break;
                }
                case 'switch': {
                    let op = stack.pop();
                    if (op === undefined) { currCommand.error = 'stack underflow'; }
                    else { CC = ((CC + op) % 2 + 2) % 2; }
                    yield { commandList, block, currCommand, stack, CC };
                    break;
                }
                case 'dup': {
                    let op = stack.pop();
                    if (op === undefined) { currCommand.error = 'stack underflow'; }
                    else { stack.push(op); stack.push(op); }
                    yield { commandList, block, currCommand, stack };
                    break;
                }
                case 'roll': {
                    let op1 = stack.pop(), op2 = stack.pop();
                    if (op1 === undefined || op2 === undefined) {
                        currCommand.error = 'stack underflow';
                        if (op1 !== undefined) stack.push(op1);
                    } else if (op2 < 0) {
                        currCommand.error = 'negative roll depth';
                        stack.push(op2); stack.push(op1);
                    } else {
                        if (op2 > stack.length) op2 = stack.length;
                        if (op1 > 0) {
                            for (let roll = 0; roll < op1; roll++) {
                                stack.splice(-op2, 0, stack[stack.length - 1]);
                                stack.pop();
                            }
                        } else {
                            for (let roll = 0; roll > op1; roll--) {
                                stack.push(...stack.splice(-op2, 1));
                            }
                        }
                    }
                    yield { commandList, block, currCommand, stack };
                    break;
                }
                case 'in(num)': {
                    let newNum = getInputNum();
                    if (newNum == null) { currCommand.error = 'invalid input'; }
                    else { stack.push(newNum); }
                    yield { commandList, block, currCommand, stack };
                    break;
                }
                case 'in(char)': {
                    let newChar = getInputChar();
                    if (newChar == null) { currCommand.error = 'invalid input'; }
                    else { stack.push(newChar.charCodeAt(0)); }
                    yield { commandList, block, currCommand, stack };
                    break;
                }
                case 'out(num)': {
                    let op = stack.pop();
                    if (op === undefined) { currCommand.error = 'stack underflow'; }
                    else { output += op; }
                    yield { commandList, block, currCommand, stack, output };
                    break;
                }
                case 'out(char)': {
                    let op = stack.pop();
                    if (op === undefined) { currCommand.error = 'stack underflow'; }
                    else { output += String.fromCharCode(op); }
                    yield { commandList, block, currCommand, stack, output };
                    break;
                }
            }
            commandList.push(currCommand);
        }
    }
}

// ============================================================
// APP STATE
// ============================================================
const HEIGHT = 10, WIDTH = 10;

const appState = {
    listeners: [],
    height: HEIGHT,
    width: WIDTH,
    cellDim: Math.min(30, (window.innerWidth - 40) / WIDTH),

    grid: Array(HEIGHT).fill(0).map(() => Array(WIDTH).fill(WHITE)),
    blocks: Array(HEIGHT).fill(0).map(() => Array(WIDTH).fill(0)),
    blockSizes: Array(HEIGHT).fill(0).map(() => Array(WIDTH).fill(HEIGHT * WIDTH)),

    selectedColour: 0,
    commands: commands[0],
    paintMode: 'BRUSH',
    cellInFocus: null,
    displayBS: false,

    subscribe(listener) { this.listeners.push(listener); },
    notify() { this.listeners.forEach(fn => fn()); },

    resize({ height, width }) {
        if (!height || height < 1 || !width || width < 1) return;
        this.height = height;
        this.width = width;
        this.cellDim = Math.min(30, (window.innerWidth - 280) / width);
        this.grid = Array(height).fill(0).map(() => Array(width).fill(WHITE));
        this.blockSizes = Array(height).fill(0).map(() => Array(width).fill(height * width));
        this.blocks = Array(height).fill(0).map(() => Array(width).fill(0));
        this.notify();
    },

    selectColour(colour) {
        this.selectedColour = colour;
        this.commands = (colour === WHITE || colour === BLACK) ? [] : commands[colour];
        this.notify();
    },

    selectPaintMode(mode) {
        this.paintMode = mode;
        this.notify();
    },

    handleCellClick(row, col) {
        switch (this.paintMode) {
            case 'BRUSH': this.brushPaint(row, col); break;
            case 'BUCKET': this.bucketPaint(row, col); break;
            case 'BP': this.debug.toggleBP(row, col); break;
        }
    },

    brushPaint(row, col) {
        this.grid[row][col] = this.selectedColour;
        let b = this.computeBlocks();
        this.blocks = b.blockMap;
        this.blockSizes = b.blockSizes;
        this.notify();
    },

    bucketPaint(row, col) {
        const self = this;
        if (this.grid[row][col] !== this.selectedColour) {
            const origColour = this.grid[row][col];
            const selectedColour = this.selectedColour;
            const stack = [[row, col]];
            while (stack.length > 0) {
                const [r, c] = stack.pop();
                if (r < 0 || r >= self.height || c < 0 || c >= self.width) continue;
                if (self.grid[r][c] !== origColour) continue;
                self.grid[r][c] = selectedColour;
                stack.push([r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]);
            }
        }
        let b = this.computeBlocks();
        this.blocks = b.blockMap;
        this.blockSizes = b.blockSizes;
        this.notify();
    },

    setCellInFocus(row, col) {
        this.cellInFocus = (row == null) ? null : [row, col];
        this.notify();
    },

    toggleDisplayBS() {
        this.displayBS = !this.displayBS;
        this.notify();
    },

    exportPng(scale) {
        scale = scale || 1;
        const canvas = document.createElement('canvas');
        canvas.width = this.width * scale;
        canvas.height = this.height * scale;
        const ctx = canvas.getContext('2d');
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                ctx.fillStyle = colours[this.grid[y][x]];
                ctx.fillRect(x * scale, y * scale, scale, scale);
            }
        }
        const link = document.createElement('a');
        link.download = 'piet_program.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    },

    importImg(file) {
        const self = this;
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const imageData = ctx.getImageData(0, 0, img.width, img.height);
                const data = imageData.data;

                self.height = img.height;
                self.width = img.width;
                self.cellDim = Math.min(30, (window.innerWidth - 280) / img.width);
                self.grid = Array(img.height).fill(0).map(() => Array(img.width).fill(WHITE));

                for (let y = 0; y < img.height; y++) {
                    for (let x = 0; x < img.width; x++) {
                        const idx = (y * img.width + x) * 4;
                        const r = data[idx], g = data[idx + 1], b = data[idx + 2];
                        // Find exact match first, then nearest colour
                        let bestIdx = WHITE;
                        let bestDist = Infinity;
                        for (let ci = 0; ci < colours.length; ci++) {
                            const [cr, cg, cb] = colourRgbs[ci];
                            const dist = (r - cr) ** 2 + (g - cg) ** 2 + (b - cb) ** 2;
                            if (dist === 0) { bestIdx = ci; break; }
                            if (dist < bestDist) { bestDist = dist; bestIdx = ci; }
                        }
                        self.grid[y][x] = bestIdx;
                    }
                }

                let blocks = self.computeBlocks();
                self.blocks = blocks.blockMap;
                self.blockSizes = blocks.blockSizes;

                // Update dimension inputs
                document.getElementById('input-height').value = self.height;
                document.getElementById('input-width').value = self.width;

                self.notify();
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    },

    computeBlocks() {
        const self = this;
        let blockMap = Array(self.height).fill(0).map(() => Array(self.width).fill(-1));
        let blockSizes = Array(self.height).fill(0).map(() => Array(self.width).fill(0));

        // Iterative flood fill to avoid stack overflow
        function labelBlock(startRow, startCol, blockColour, label) {
            const stack = [[startRow, startCol]];
            let size = 0;
            while (stack.length > 0) {
                const [r, c] = stack.pop();
                if (r < 0 || r >= self.height || c < 0 || c >= self.width) continue;
                if (blockMap[r][c] !== -1 || self.grid[r][c] !== blockColour) continue;
                blockMap[r][c] = label;
                size++;
                stack.push([r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]);
            }
            return size;
        }

        let labelMap = [];
        for (let i = 0; i < self.height; i++) {
            for (let j = 0; j < self.width; j++) {
                if (blockMap[i][j] === -1) {
                    labelMap.push(labelBlock(i, j, self.grid[i][j], labelMap.length));
                }
            }
        }

        for (let i = 0; i < self.height; i++) {
            for (let j = 0; j < self.width; j++) {
                blockSizes[i][j] = labelMap[blockMap[i][j]];
            }
        }

        return { blockMap, blockSizes };
    },

    debug: {
        debugIsVisible: true,
        commandList: [],
        interpreter: null,
        runner: null,
        runSpeed: 500,
        breakpoints: [],
        DP: 0, CC: 0,
        stack: [],
        output: '',
        input: '',
        inputPtr: 0,
        block: null,
        currCommand: null,

        setRunSpeed(speed) {
            this.runSpeed = speed;
            appState.notify();
        },

        selectBlock(block) {
            this.block = block;
            appState.notify();
        },

        initDebugger() {
            this.commandList = [];
            this.DP = 0; this.CC = 0;
            this.stack = []; this.output = '';
            this.inputPtr = 0;
            this.block = appState.blocks[0][0]; this.currCommand = null;
            this.interpreter = null;
            this.receiveInput();
            appState.notify();

            this.interpreter = interpret(
                appState.grid, appState.blocks, appState.blockSizes,
                this.getInputNum.bind(this), this.getInputChar.bind(this)
            );
        },

        receiveInput() {
            this.input = document.getElementById('in').value;
        },

        getInputNum() {
            if (this.input.length < this.inputPtr) return null;
            // skip whitespace
            while (this.inputPtr < this.input.length && /\s/.test(this.input[this.inputPtr])) {
                this.inputPtr++;
            }
            let num = '';
            while (this.inputPtr < this.input.length && /[0-9]/.test(this.input[this.inputPtr])) {
                num += this.input[this.inputPtr++];
            }
            if (num.length === 0) return null;
            return parseInt(num);
        },

        getInputChar() {
            if (this.input.length <= this.inputPtr) return null;
            return this.input[this.inputPtr++];
        },

        toggleSetBP() {
            appState.paintMode = (appState.paintMode === 'BP') ? 'BRUSH' : 'BP';
            appState.notify();
        },

        toggleBP(row, col) {
            let block = appState.blocks[row][col];
            let i = this.breakpoints.indexOf(block);
            if (i === -1) { this.breakpoints.push(block); }
            else { this.breakpoints.splice(i, 1); }
            appState.notify();
        },

        start() {
            this.initDebugger();
            this.cont();
        },

        step() {
            if (!this.interpreter) { this.initDebugger(); return; }
            let s = this.interpreter.next();
            if (!s.done) {
                for (let prop in s.value) this[prop] = s.value[prop];
                appState.notify();
            } else {
                this.interpreter = null;
                appState.notify();
            }
        },

        cont() {
            const self = this;
            function updateDebugger() {
                if (!self.interpreter) {
                    clearInterval(self.runner);
                    return;
                }
                let s = self.interpreter.next();
                if (s.done) {
                    self.interpreter = null;
                    appState.notify();
                } else {
                    for (let prop in s.value) self[prop] = s.value[prop];
                    appState.notify();
                    if (self.breakpoints.includes(s.value.block)) {
                        clearInterval(self.runner);
                    }
                }
            }
            this.runner = window.setInterval(updateDebugger, this.runSpeed);
        },

        stop() {
            this.interpreter = null;
            this.block = null;
            this.currCommand = null;
            clearInterval(this.runner);
            appState.notify();
        },

        pause() {
            clearInterval(this.runner);
        },
    },
};

// ============================================================
// RENDERING
// ============================================================
let gridCells = []; // 2D array of <td> references for efficient updates
let lastGridHeight = 0, lastGridWidth = 0;

function buildGrid() {
    const tbody = document.getElementById('grid-body');
    tbody.innerHTML = '';
    gridCells = [];

    for (let i = 0; i < appState.height; i++) {
        const tr = document.createElement('tr');
        const row = [];
        for (let j = 0; j < appState.width; j++) {
            const td = document.createElement('td');
            td.title = '(' + j + ',' + i + ')';
            td.style.height = appState.cellDim + 'px';
            td.style.width = appState.cellDim + 'px';
            td.dataset.row = i;
            td.dataset.col = j;
            row.push(td);
            tr.appendChild(td);
        }
        gridCells.push(row);
        tbody.appendChild(tr);
    }

    lastGridHeight = appState.height;
    lastGridWidth = appState.width;
}

function updateGrid() {
    if (appState.height !== lastGridHeight || appState.width !== lastGridWidth) {
        buildGrid();
    }

    for (let i = 0; i < appState.height; i++) {
        for (let j = 0; j < appState.width; j++) {
            const td = gridCells[i][j];
            const colIdx = appState.grid[i][j];
            const colour = colours[colIdx];
            const isBreakpoint = appState.debug.breakpoints.includes(appState.blocks[i][j]);

            td.style.height = appState.cellDim + 'px';
            td.style.width = appState.cellDim + 'px';
            td.style.cursor = { 'BRUSH': 'crosshair', 'BUCKET': 'cell', 'BP': 'pointer' }[appState.paintMode] || 'default';

            if (isBreakpoint) {
                td.style.background = 'repeating-linear-gradient(45deg, ' + colour + ', ' + colour + ' 2px, black 2px, black 4px)';
            } else {
                td.style.background = colour;
            }

            // Active block highlight — white outline around the entire block's perimeter
            const activeBlock = appState.debug.block;
            const isActiveBlock = activeBlock != null && appState.blocks[i][j] === activeBlock;
            if (isActiveBlock) {
                const shadows = [];
                const wo = 4; // outer white border width
                const wi = 6; // outer + inner black (4 + 2)
                const isTop = i === 0 || appState.blocks[i - 1][j] !== activeBlock;
                const isBot = i === appState.height - 1 || appState.blocks[i + 1][j] !== activeBlock;
                const isLft = j === 0 || appState.blocks[i][j - 1] !== activeBlock;
                const isRgt = j === appState.width - 1 || appState.blocks[i][j + 1] !== activeBlock;
                // White outer layer first, then black inner layer (order matters: first listed = on top)
                if (isTop) shadows.push('inset 0 ' + wo + 'px 0 0 white');
                if (isBot) shadows.push('inset 0 -' + wo + 'px 0 0 white');
                if (isLft) shadows.push('inset ' + wo + 'px 0 0 0 white');
                if (isRgt) shadows.push('inset -' + wo + 'px 0 0 0 white');
                if (isTop) shadows.push('inset 0 ' + wi + 'px 0 0 black');
                if (isBot) shadows.push('inset 0 -' + wi + 'px 0 0 black');
                if (isLft) shadows.push('inset ' + wi + 'px 0 0 0 black');
                if (isRgt) shadows.push('inset -' + wi + 'px 0 0 0 black');
                td.style.boxShadow = shadows.length ? shadows.join(',') : 'none';
            } else {
                td.style.boxShadow = 'none';
            }

            // Cell content
            if (appState.displayBS && appState.blockSizes[i][j]) {
                td.textContent = appState.blockSizes[i][j];
            } else {
                td.textContent = '';
            }
        }
    }
}

function updateControls() {
    const isInterpreting = appState.debug.interpreter != null;

    // Import/Resize disable state
    document.getElementById('import-btn').disabled = isInterpreting;
    document.getElementById('resize-btn').disabled = isInterpreting;

    // Paint mode buttons
    document.getElementById('brush-btn').className = 'btn btn-default paint-mode-btn' + (appState.paintMode === 'BRUSH' ? ' active-mode' : '');
    document.getElementById('bucket-btn').className = 'btn btn-default paint-mode-btn' + (appState.paintMode === 'BUCKET' ? ' active-mode' : '');

    // Block size toggle icon
    const bsToggle = document.getElementById('bs-toggle');
    bsToggle.className = appState.displayBS ? 'glyphicon glyphicon-eye-open' : 'glyphicon glyphicon-eye-close';

    // Block info
    const blockInfo = document.getElementById('block-info');
    if (appState.cellInFocus) {
        const [r, c] = appState.cellInFocus;
        blockInfo.innerHTML = '<b>' + appState.blockSizes[r][c] + ' pixels in block</b>';
    } else {
        blockInfo.innerHTML = '';
    }

    // Input readonly when interpreting
    document.getElementById('in').readOnly = isInterpreting;
}

function updateDebugger() {
    // BP toggle colour
    document.getElementById('bp-toggle').style.color = appState.paintMode === 'BP' ? 'red' : 'black';

    // Speed slider
    document.getElementById('speed-slider').value = 1000 - appState.debug.runSpeed;

    // Pointers
    const dpArrows = ['right', 'down', 'left', 'up'];
    const ccArrows = ['left', 'right'];
    document.getElementById('pointers').innerHTML =
        'DP:&nbsp;<i class="glyphicon glyphicon-arrow-' + dpArrows[appState.debug.DP] + '"></i>&emsp;' +
        'CC:&nbsp;<i class="glyphicon glyphicon-arrow-' + ccArrows[appState.debug.CC] + '"></i>';

    // Stack
    const stackBody = document.getElementById('stack-body');
    stackBody.innerHTML = '';
    const stackDisplay = appState.debug.stack.concat(['\u2B9F']); // ⮟
    for (const val of stackDisplay) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.textContent = val;
        tr.appendChild(td);
        stackBody.appendChild(tr);
    }

    // Command list
    const cmdList = document.getElementById('command-list');
    cmdList.innerHTML = '';
    const isInterpreting = appState.debug.interpreter != null;
    for (let i = 0; i < appState.debug.commandList.length; i++) {
        const cmd = appState.debug.commandList[i];
        if (isInterpreting && cmd === appState.debug.currCommand) continue;
        const div = document.createElement('div');
        div.className = 'command-entry';
        div.textContent = cmd.inst;
        if (cmd.error) {
            div.innerHTML += ' <i class="glyphicon glyphicon-exclamation-sign" style="color:red;" title="' + cmd.error + '"></i>';
        }
        div.onmouseover = function() { if (!isInterpreting) appState.debug.selectBlock(cmd.block); };
        div.onmouseout = function() { if (!isInterpreting) appState.debug.selectBlock(null); };
        cmdList.appendChild(div);
    }
    // Append current command inline (bold to distinguish from history)
    if (isInterpreting && appState.debug.currCommand) {
        const div = document.createElement('div');
        div.className = 'command-entry';
        div.style.fontWeight = 'bold';
        div.textContent = appState.debug.currCommand.inst;
        if (appState.debug.currCommand.error) {
            div.innerHTML += ' <i class="glyphicon glyphicon-exclamation-sign" style="color:red;" title="' + appState.debug.currCommand.error + '"></i>';
        }
        cmdList.appendChild(div);
    }
    // Auto-scroll command list to bottom
    cmdList.scrollTop = cmdList.scrollHeight;

    // Output
    document.getElementById('out').value = appState.debug.output;
}

function updateColourPicker() {
    const tbody = document.getElementById('colour-picker-body');
    tbody.innerHTML = '';

    const colourRows = [
        colours.slice(0, 6).map((_, j) => j),
        colours.slice(6, 12).map((_, j) => 6 + j),
        colours.slice(12, 18).map((_, j) => 12 + j),
    ];

    for (const row of colourRows) {
        const tr = document.createElement('tr');
        for (const ci of row) {
            const td = document.createElement('td');
            td.style.backgroundColor = colours[ci];
            if (appState.selectedColour === ci) td.className = 'selected';
            td.textContent = appState.commands[ci] || '';
            td.onclick = () => appState.selectColour(ci);
            tr.appendChild(td);
        }
        tbody.appendChild(tr);
    }

    const tr = document.createElement('tr');
    const tdWhite = document.createElement('td');
    tdWhite.colSpan = 3;
    tdWhite.style.backgroundColor = colours[WHITE];
    if (appState.selectedColour === WHITE) tdWhite.className = 'selected';
    tdWhite.onclick = () => appState.selectColour(WHITE);
    tr.appendChild(tdWhite);

    const tdBlack = document.createElement('td');
    tdBlack.colSpan = 3;
    tdBlack.style.backgroundColor = colours[BLACK];
    if (appState.selectedColour === BLACK) tdBlack.className = 'selected';
    tdBlack.onclick = () => appState.selectColour(BLACK);
    tr.appendChild(tdBlack);

    tbody.appendChild(tr);
}

function render() {
    updateGrid();
    updateColourPicker();
    updateControls();
    updateDebugger();
}

// ============================================================
// EVENT BINDINGS
// ============================================================
function init() {
    // Subscribe to state changes
    appState.subscribe(render);

    // Grid mouse events (delegation)
    const gridBody = document.getElementById('grid-body');
    gridBody.addEventListener('click', function(e) {
        const td = e.target.closest('td');
        if (td && td.dataset.row !== undefined) {
            appState.handleCellClick(parseInt(td.dataset.row), parseInt(td.dataset.col));
        }
    });
    gridBody.addEventListener('mouseover', function(e) {
        const td = e.target.closest('td');
        if (td && td.dataset.row !== undefined) {
            appState.setCellInFocus(parseInt(td.dataset.row), parseInt(td.dataset.col));
        }
    });
    document.getElementById('grid-table').addEventListener('mouseout', function(e) {
        // Only clear if leaving the table entirely
        if (!e.relatedTarget || !document.getElementById('grid-table').contains(e.relatedTarget)) {
            appState.setCellInFocus(null);
        }
    });

    // Import
    document.getElementById('import-btn').addEventListener('click', function() {
        document.getElementById('fileChooser').click();
    });
    document.getElementById('fileChooser').addEventListener('change', function(e) {
        if (e.target.files[0]) {
            appState.importImg(e.target.files[0]);
            e.target.value = '';
        }
    });

    // Export
    document.getElementById('export-btn').addEventListener('click', function() {
        appState.exportPng(parseInt(document.getElementById('scale').value) || 1);
    });


    // Paint mode
    document.getElementById('brush-btn').addEventListener('click', function() {
        appState.selectPaintMode('BRUSH');
    });
    document.getElementById('bucket-btn').addEventListener('click', function() {
        appState.selectPaintMode('BUCKET');
    });

    // Resize
    document.getElementById('resize-btn').addEventListener('click', function() {
        appState.resize({
            height: parseInt(document.getElementById('input-height').value),
            width: parseInt(document.getElementById('input-width').value),
        });
    });

    // Block size toggle
    document.getElementById('bs-toggle').addEventListener('click', function() {
        appState.toggleDisplayBS();
    });

    // Debug controls
    document.getElementById('debug-run').addEventListener('click', function() {
        appState.debug.start();
    });
    document.getElementById('debug-pause').addEventListener('click', function() {
        appState.debug.pause();
    });
    document.getElementById('debug-step').addEventListener('click', function() {
        appState.debug.step();
    });
    document.getElementById('debug-cont').addEventListener('click', function() {
        appState.debug.cont();
    });
    document.getElementById('debug-stop').addEventListener('click', function() {
        appState.debug.stop();
    });

    // Speed slider
    document.getElementById('speed-slider').addEventListener('input', function(e) {
        const isInterpreting = appState.debug.interpreter != null;
        if (!isInterpreting) {
            appState.debug.setRunSpeed(1000 - parseInt(e.target.value));
        }
    });

    // Breakpoint toggle
    document.getElementById('bp-toggle').addEventListener('click', function() {
        appState.debug.toggleSetBP();
    });

    // Floating panel drag
    function makeDraggable(panel) {
        const header = panel.querySelector('.float-panel-header');
        let startX, startY, startLeft, startTop;
        header.addEventListener('mousedown', function(e) {
            startX = e.clientX;
            startY = e.clientY;
            startLeft = parseInt(panel.style.left) || panel.getBoundingClientRect().left;
            startTop = parseInt(panel.style.top) || panel.getBoundingClientRect().top;
            function onMouseMove(e) {
                panel.style.left = (startLeft + e.clientX - startX) + 'px';
                panel.style.top = (startTop + e.clientY - startY) + 'px';
            }
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            e.preventDefault();
        });
    }
    document.querySelectorAll('.float-panel').forEach(makeDraggable);

    // Initial render
    buildGrid();
    render();

    // Position panels in 4-column layout
    const GAP = 10;

    // Col 1: Piet (already at left:10px, top:10px)
    const pietRect = document.getElementById('panel-canvas').getBoundingClientRect();

    // Col 2: Code
    const codePanel = document.getElementById('panel-code');
    codePanel.style.left = (pietRect.right + GAP) + 'px';
    codePanel.style.top = pietRect.top + 'px';
    const codeRect = codePanel.getBoundingClientRect();

    // Col 3: Stack, Input, Output (stacked vertically)
    const col3Left = codeRect.right + GAP;
    let col3Top = pietRect.top;

    const stackPanel = document.getElementById('panel-stack');
    stackPanel.style.left = col3Left + 'px';
    stackPanel.style.top = col3Top + 'px';
    const stackRect = stackPanel.getBoundingClientRect();
    col3Top = stackRect.bottom + GAP;

    const inputPanel = document.getElementById('panel-input');
    inputPanel.style.left = col3Left + 'px';
    inputPanel.style.top = col3Top + 'px';
    const inputRect = inputPanel.getBoundingClientRect();
    col3Top = inputRect.bottom + GAP;

    const outputPanel = document.getElementById('panel-output');
    outputPanel.style.left = col3Left + 'px';
    outputPanel.style.top = col3Top + 'px';
    const outputRect = outputPanel.getBoundingClientRect();

    // Col 4: Debug Controls, Commands (stacked vertically)
    const col4Left = Math.max(stackRect.right, inputRect.right, outputRect.right) + GAP;
    let col4Top = pietRect.top;

    const controlsPanel = document.getElementById('panel-controls');
    controlsPanel.style.left = col4Left + 'px';
    controlsPanel.style.top = col4Top + 'px';
    const controlsRect = controlsPanel.getBoundingClientRect();
    col4Top = controlsRect.bottom + GAP;

    const commandsPanel = document.getElementById('panel-commands');
    commandsPanel.style.left = col4Left + 'px';
    commandsPanel.style.top = col4Top + 'px';
}

document.addEventListener('DOMContentLoaded', init);

})();
</script>
</body>
</html>
